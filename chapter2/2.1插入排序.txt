2.1-1 以图2-2为模型,说明INSERTION-SORT在数组A={31,41,59,26,41,58}上的执行
      过程
      答: 1    2   3   4   5   6
          31   41  59  26  41  58
          31   41  59  26  41  58
          26   31  41  59  41  58
          26   31  41  41  59  58
          26   31  41  41  58  59
          
2.1-2 重新过程INSERTION-SORT,使之按非升序(而不是非降序)排序
      INSERTION-SORT(A)  
      for j = 2 to A.length 
        key = A[j]  
        i = j - 1  
        while i > 0 and A[i] < key  //将判断大于改为小于即可.
             A[i+1] = A[i]  
             i = i - 1  
        A[i+1] = key  

2.1-3 考虑以下查找问题:
      输入: n个数的一个序列A=<a1,a2,...an>和一个值v
      输出: 下标i使得v=A[i]或者当v不在A中出现时,v为特殊值NIL.
      写出线性查找的伪代码,它扫描整个序列来查找v,使用一个循环不变式来
      证明你的算法是正确的.确保你的循环不变试满足三条必要的性质.
      答: 
         FIND-V(A,v)
            i = 0
            while i < A.length and A[i] != v
               i += 1
            if i < A.length
               OUT i
            else
               OUT NIL
      正确性:
        初始化:
            i = 0, while 循环迭代前不变式成立,
        保持:
            i 从 0 递增到A.length. 如果A[i] = v,则循环体结束.
        终止:
            退出循环后,判断i是否在A.length里,如果在,则输出i,否则i为NIL.
            
2.1-4 考虑把两个n位二进制整数加起来的问题,这两个整数分别存储在两个n元数组A
      和B中,这两个整数的和应按二进制形式存储在一个(n+1)元数组C中,请给出该
      问题的形式化描述,并写出伪代码.
      答:
        因为C为n+1位,故可以在C[n+1]存放A+B需要进位的数. 将C初始化为0,
        当A+B+C大于2时,说明需要进位,故C[n+1]被置为1,而当前位为(A+B+C)%2;
        当A+B+C小于2时,说明不需要进位,当前位等于A+B
        
        SUM(A,B,C,n)
          C[0~n+1] = 0;
          for i = 0 to n;
            if A[i] + B[i] + C[i] >= 2 //需要进位
                c[i] = (A[i] + B[i] + C[i])%2 //当前位取2的模
                c[i+1] = 1;   //实现进位
            else
                c[i] = A[i] + B[i]; // 0 或 1
      
      